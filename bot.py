# -*- coding: utf-8 -*-
"""bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vyxlAjzEjo9edUK-GnhBVGABVF7Ym2gz
"""

import os
import pandas as pd
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
import logging
import nest_asyncio
import asyncio

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelень)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Enable nested asyncio loops
nest_asyncio.apply()

# Global variable to store the lessons and participants
lessons = {}
participants = set()

# Path to the uploaded Excel file
excel_file_path = '/mnt/data/Super Star 2024.xlsx'  # Adjust the path

# Function to load and clean lesson files
def load_lessons(excel_file_path):
    global lessons, participants
    lessons = {}
    participants = set()
    try:
        excel_data = pd.ExcelFile(excel_file_path)
        lesson_days = ['Lessons_Monday', 'Lessons_Tuesday', 'Lessons_Wednesday', 'Lessons_Thursday', 'Lessons_Friday']
        for day in lesson_days:
            df = pd.read_excel(excel_file_path, sheet_name=day, skiprows=2)
            df.columns = df.iloc[0]  # Set the first row as the header
            df = df.drop(0).reset_index(drop=True)  # Drop the first row and reset index
            lessons[day.strip()] = df
            for column in df.columns[1:]:
                participants.update(df[column].dropna().unique())
        logger.info("Lessons have been loaded from the Excel file")
    except Exception as e:
        logger.error(f"Error loading lessons: {e}")

# Function to extract schedule for a given dancer
def get_schedule(dancer_name):
    schedule = {}
    try:
        for day, df in lessons.items():
            trainers = df.iloc[0]  # First row contains trainer names
            day_schedule = []
            for index, row in df.iterrows():
                if index == 0:
                    continue  # Skip the first row with trainer names
                time = row[df.columns[0]]
                for col in df.columns[1:]:
                    if pd.notna(row[col]) and dancer_name.lower() in str(row[col]).lower():
                        trainer = trainers[col]
                        day_schedule.append(f"{time} - {trainer.strip()}")
            if day_schedule:
                schedule[day] = day_schedule
    except Exception as e:
        logger.error(f"Error getting schedule: {e}")
    return schedule

# Function to format the schedule for a given dancer
def format_schedule(dancer_name):
    schedule = get_schedule(dancer_name)
    if not schedule:
        return f"Не знайдено розкладу для {dancer_name}."

    response = f"Для Вас, {dancer_name}, заброньовано такі уроки:\n"
    for day, lessons in schedule.items():
        response += f"\n{day}:\n"
        for lesson in lessons:
            response += f"{lesson}\n"
    return response

# Start command handler
async def start(update: Update, context: CallbackContext) -> None:
    logger.info("Received /start command")
    keyboard = [
        [KeyboardButton("Розклад лекцій")],
        [KeyboardButton("Переглянути розклад моїх індивідуальних уроків")],
        [KeyboardButton("Готелі для розміщення")],
        [KeyboardButton("Ціни")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text('Добрий день! Як я можу Вам допомогти?', reply_markup=reply_markup)

# Handler for text messages
async def handle_text(update: Update, context: CallbackContext) -> None:
    text = update.message.text
    if text == "Розклад лекцій":
        await update.message.reply_photo(photo=open('schedule.jpg', 'rb'))  # Adjust the path
    elif text == "Переглянути розклад моїх індивідуальних уроків":
        keyboard = [[KeyboardButton(name)] for name in sorted(participants)]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text('Будь ласка, виберіть своє ім\'я або введіть його вручну:', reply_markup=reply_markup)
    elif text in participants:
        response = format_schedule(text)
        await update.message.reply_text(response)
    elif text == "Готелі для розміщення":
        await update.message.reply_document(document=open('hotels.pdf', 'rb'))  # Adjust the path
    elif text == "Ціни":
        await update.message.reply_photo(photo=open('price_ukr.jpg', 'rb'))  # Adjust the path
        await update.message.reply_photo(photo=open('price_camp_international.jpg', 'rb'))  # Adjust the path
    else:
        response = format_schedule(text)
        await update.message.reply_text(response)

# Command handler to reload the Excel file
async def reload(update: Update, context: CallbackContext) -> None:
    load_lessons(excel_file_path)
    logger.info("Reload command received, reloading the lessons")
    await update.message.reply_text('The schedule has been reloaded from the Excel file.')

# Main function to set up the bot
async def main() -> None:
    application = Application.builder().token("7255189052:AAEgqNJiHUKDhmIsuT7oRJO3uOv9wRIb0Ms").build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("reload", reload))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    # Initial load of the lessons
    load_lessons(excel_file_path)

    await application.initialize()  # Initialize the application
    await application.start()
    await application.updater.start_polling()

# Run the bot using the existing event loop
loop = asyncio.get_event_loop()
loop.create_task(main())
try:
    loop.run_forever()
except KeyboardInterrupt:
    print("Bot stopped.")